# C언어 이론

---
## 아스키 코드
  * C프로그램의 문자는 아스키코드(ASCII Code)를 따른다
  * 아스키 코드는 0~127 중의 1바이트로 구성되며 주요 문자를 출력해준다.
    + 0 : 48 , A : 65 , a : 97
  * 한개의 문자를 입력받기 위해서는 getchar() 함수를 사용하면 된다.

---
## 문자
  * 문자를 처리할 때 버퍼의 개념이 많이 사용된다.
  * 버퍼(Buffer)란 임시적으로 특정한 데이터를 저장하기 위한 목적으로 사용된다.
  * C프로그램은 기본적으로 사용자가 의도하지 않아도 자동으로 버퍼를 이용해 입출력을 처리한다.
---
## 입력 버퍼로 인해 흔히 발생하는 오류
  ```
  scanf("%d",&a)
  printf("%d",a)
  scanf("%d",&b)
  printf("%d",b)
  ```

  * 컴퓨터는 공백이나 줄바꿈도 다 아스키코드로 관리를 하는데, 숫자를 입력한 뒤 엔터(줄바꿈)을 치면
  a에는 정상적으로 숫자가 들어가지만, b에는 엔터(공백)이 들어가서 문자로 처리한다.
  * 이 문제를 해결하기 위해서, 사이에 이 구문을 넣어주면 된다.
  ```
  while((temp = getchar()) != EOF && temp != '\n'){}
  // 한 자씩 받아서 파일의 끝이거나 개행 문자를 만나면 입력을 멈추므로 항상 입력 버퍼를 비운다.
  ```

---

## 문자열
  * 문자열은 말 그대로 문자들의 배열이다.
  * 문자열은 컴퓨터 메모리 구조상에서 마지막에 NULL(\0)값을 포함한다.
  * 널 값은 문자열의 끝을 알리는 목적으로 사용된다.
  * printf() 함수를 실행하면 컴퓨터는 내부적으로 NULL을 만날 때까지 출력한다.

---
## 문자열과 포인터
  * 문자열 형태로 포인터를 사용하면 포인터에 특정한 문자열의 주소를 넣게 된다.
  * 다음 코드는 "Hello world"문자열을 읽기 전용으로 메모리 공간에 넝흔 뒤에 그 위치를 처리한다.
  * 이러한 문자열을 '문자열 리터럴' 이라고 한다. 이는 컴파일러가 알아서 메모리 주소를 결정한다.
    > char * a = "Hello world !"

---

## 문자열 입출력 함수
  * 문자열 입출력을 수행한다
  * scanf() 함수는 공백을 만날 때까지 입력을 받지만, gets() 함수는 공백을 포함하여 한 줄을 입력받는다.
    - 실무 개발환경에서는 gets_s() 를 사용.
    ```
    gets_s(a,sizeof(a));
    //버퍼의 크기를 철저히 지키기 위해 사용, gets_s를 사용하는 경우 범위를 넘으면 그 즉시 런타임(Runtime)오류가 발생
    ```

---
## 문자열 처리를 위한 다양한 함수
  * C언어에서는 <string.h> 라이브러리에 포함되어 있다 .
    - strlen() : 문자열의 길이를 반환
    - strcmp() : 문자열1이 문자열2보다 사전적으로 앞에 있으면 -1, 뒤에 있으면 1 반환
    - strcpy() : 문자열을 복사
    - strcat() : 문자열1 에 문자열2를 더함
    - strstr() : 문자열1에 문자열2가 어떻게 포함되어 있는지를 반환
      + 포함되는 부분의 인덱스부터 끝까지 출력
---

## 컴퓨터가 변수를 처리하는 방법

  * 프로그램 메모리 주소
    - 1) 컴퓨터에서 프로그램이 실행되기 위해서는 프로그램이 메모리에 적재(Load)되어야 함
    - 2) 당연히 프로그램의 크기를 충당할 수 있을 만큼의 메모리 공간이 있어야 한다.
    - 3) 일반적인 컴퓨터 운영체제는 메모리 공간을 네 가지로 구분하여 관리한다.
      + 코드 영역 - 소스코드
      + 데이터 영역 - 전역 변수, 정적 변수
      + 힙 영역 - 동적 할당 변수
      + 스택 영역 - 지역 변수, 매개변수

![process](https://t1.daumcdn.net/cfile/tistory/114A773E511554972A)

---
## 전역 변수

  * 1) 전역 변수(Global Variable)란 프로그램의 어디서든 접근 가능한 변수를 말합니다.
  * 2) main함수가 실행되기도 전에 프로그램의 시작과 동시에 메모리에 할당된다.
  * 3) 프로그램의 크기가 커질 수록 전역 변수로 인해 프로그램이 복잡해질 수 있다.
  * 4) 메모리의 데이터(Data) 영역에 적재된다.

---
## 지역 변수

  * 1) 지역변수(Local Variable)란 프로그램에서 특정한 블록(block) 에서만 접근할 수 있는 변수를 말한다.
  * 2) 함수가 실행될때 마다 메모리에 할당되어 함수가 종료되면 메모리에서 해제된다.
  * 3) 메모리의 스택(stack) 영역에 기록된다.
---
## 정적 변수

  * 1) 정적 변수(Static Variable)란 특정한 블록안에서만 접근 할 수 있는 변수
  * 2) 프로그램이 실행될 때 메모리에 할당되어 프로그램이 종료되면 메모리에서 해제된다.
  * 3) 메모리의 데이터(Data) 영역에 적재된다.
---
## 레지스터 변수

  * 1) 레지스터 변수(Register Variable)란 메인 메모리 대신 CPU의 레지스터를 사용하는 변수이다.
  * 2) 레지스터는 매우 한정되어 있으므로 실제로 레지스터에서 처리될지는 장담할 수 없다.
  ```
    register int a = 10;
  ```

---
## 함수의 매개변수가 처리될 때

  * 1) 함수를 호출할 때 함수에 필요한 데이터를 매개변수로 전달한다.
  * 2) 전달 방식은 <값에 의한 전달> 방식과 <참조에 의한 전달> 방식이 있다.
  * 3) 값에 의한 전달 방식은 단지 값을 전달하므로 함수 내에서 변수가 자유롭게 생성된다.
  * 4) 참조에 의한 전달 방식은 주소를 전달(포인터를 이용)하므로 원래의 변수 자체에 접근할 수 있다.

---
## 2차원 배열과 포인터 배열

  * 1) 2차원 배열은 굉장히 많은 목적으로 사용됨
  * 2) 행렬 데이터를 표현할 때, 그래프 알고리즘을 처리할 때 , 다수의 실생활 데이터를 처리할 때 등
  * 3) 흔히 우리가 보는 표 구조가 2차원 배열과 흡사하다.

---
## 2차원 배열

  * 2차원 배열은 1차원 배열이 중첩되었다는 의미로 [][]대괄호를 중첩하여 쓴다
    > 자료형 배열이름 [행][열] = {{값,값,값..},{값,값...},{..}...}

---
## 다차원 배열

  * 2차원 배열 이상의 다차원 배열 또한 사용할 수 있다.
  * 우리 컴퓨터는 기본적으로 화면에 2차원 형태만 출력할 수 있다.

---
## 포인터 배열

  * 포인터 배열의 구조분석
    - 1) 배열은 포인터와 동일한 방식으로 동작한다.
    - 2) 배열의 이름은 배열의 원소의 첫 번째 주소가 된다.
    - 3) 유일한 차이점은 포인터는 변수이며 , 배열의 이름은 상수이다.
  * 포인터는 연산을 통해 자료형의 크기만큼 이동한다
    - 따라서 정수(int)형 포인터는 4바이트(Bytes)씩 이동한다.

---
## 동적 메모리 할당

  * 1) 일반적으로 C언어에서 배열의 경우 사전에 적절한 크기만큼 할당해주어야 한다.
  * 2) 우리가 원하는 만큼만 메모리를 할당해서 사용하고자 한다면 동적 메모리 할당을 사용한다
  * 3) 동적이라는 말의 의미는 '프로그램 실행 도중에' 라는 의미이다.
---
## 동적메모리

  * 1) C언어에서는 malloc()함수를 이용해 원하는 만큼의 메모리를 확보할 수 있다.
  * 2) malloc() 함수는 메모리 할당에 성공하면 주소를 반환하고, 그렇지 않으면 NULL을 반환한다.
  * 3) malloc() 함수는 <stdlib.h> 라이브러리에 정의되어있다.
  ```
  malloc(할당할 바이트 크기);
  ```

  * 4) 동적으로 할당된 변수는 <힙 영역>에 저장된다.
---
## 동적 메모리 할당 중요한 점

  * 1) 전통적인 C언어에서는 스택에 선언된 변수는 따로 메모리 해제를 해주지 않아도 된다.
  * 2) 반면에 동적으로 할당된 변수는 반드시 free() 함수로 메모리 해제를 해주어야한다.
  * 3) 메모리 해제를 하지 않으면 메모리 내의 프로세스 무게가 더해져 언젠가는 오류가 발생한다.
  * 4) 메모리 누수(memory leak) 방지는 코어 개발자의 핵심 역량이다.
---
## 동적으로 문자열 처리하기

  * 1) 일괄적인 범위의 메모리를 모두 특정한 값으로 설정하기 위해서는 memset()을 사용한다.
  * 2) memset(포인터,값,크기);
  * 3) 한 바이트 씩 값을 저장하므로 문자열 배열의 처리 방식과 흡사하다.
  * 4) 따라서 memset() 함수는 <string.h> 라이브러리 안에 선언되어 있다.
---
## 정리

  * 동적 메모리 할당을 이용하면 프로그램 실행도중 메모리 공간을 배정받을 수 있다
  * 동적으로 할당받은 프로그램은 반드시 명시적으로 free()함수를 이용해 할당 해제를 해야만 한다.

---
## 함수 포인터

  * C언어에서는 함수의 이름을 이용해 특정한 함수를 호출한다.
  * 함수 이름은 메모리 주소를 반환한다.
  * 함수 포인터는 특정한 함수의 반환 자료형을 지정하는 방식으로 선언할 수 있다.
  * 함수 포인터를 이용하면 형태가 서로 같은 서로 다른 기능의 함수를 선택적으로 사용할 수 있다.
  > usage : 반환 자료형(* 이름)(매개변수) = 함수명;
  ```
  void(* fp)() = function; // 반환값, 매개변수가 없는 경우
  fp();
  int(* fp)(int,int) = function //반환값이 int, 매개변수 int,int를 받는경우
  fp(3,5);
  ```
---
## 정리

  * C언어 프로그램의 모든 함수는 내부적으로 포인터 형태로 관리할 수 있다.
  * 함수 포인터는 자주 사용되지 않지만 알고 있으면 컴퓨터 구조를 이해하는데 도움을 준다.

---
## 구조체

  * 1) 여러개의 변수를 묶어 하나의 객체를 표현하고자 할때 사용할 수 있다.
  * 2) 캐릭터,몬스터,학생,좌표 등 다양한 객체를 모두 프로그래밍 언어를 이용해 표현할 수 있다.
  ```
  struct 구조체명 { 자료형1 변수명1 자료형2 변수명2 ....};
  //구조체 선언 : struct 구조체명 변수명;
  typedef struct 구조체명 { 자료형1 변수명1 자료형2 변수명2 ....} 자료형;
  //typedef 키워드를 이용하면 임의의 자료형을 만들 수 있으므로 선언이 더 짧아진다.
  ```
---

## 파일 입출력
  * 파일 입출력의 필요성
    - 프로그램이 꺼진 이후에도 데이터를 저장하기 위해서는 파일 입출력이 필요하다.
    - 게임을 껐다 킬 때마다 다시 처음부터 캐릭터를 키워야한다면 매우 억울한 경우 발생.
    - 실질적으로 저장매체(ssd,hdd)에 저장
---

## 파일 입출력
  * 파일 입출력 변수는 FILE 형식의 포인터 변수로 선언한다.
  * 파일을 열때는 fopen() 함수를 이용한다.
  * 파일을 닫을 때는 fclose() 함수를 이용한다.
  ```
  FILE * fp; fp = fopen(파일 경로, 접근 방식);
  fclose(fp);
  ```

---
## fopen()?
  * 파일 열기 함수인 fopen() 함수는 파일 경로와 접근 방식을 설정할 수 있다.
  * 기본 경로는 현재 프로그램의 경로이다.
  * 가장 많이 사용되는 접근 방식은 다음과 같다
    - r : 파일에 접근하여 데이터를 읽는다.
    - w : 파일에 접근하여 데이터를 기록한다. (파일이 이미 존재하면 덮어쓰기)
    - a : 파일에 접근하여 데이터를 뒤에서부터 기록한다.

---

## 파일 입출력 함수
  * 기본적으로 입출력을 위해서 printf(), scanf()함수를 사용했다.
  * 파일 입출력에서는 그 대신에 fprintf(), fscanf()가 사용된다.
  ```
  fprintf(파일 포인터,서식,형식지정자);
  fscanf(파일 포인터,서식,형식지정자);
  ```

---
## 파일 입출력의 과정
  * 파일 입출력은 열고, 읽고/쓰고, 닫기의 과정을 철저히 따라야 한다.
  * 파일을 열 때는 파일 포인터가 사용되며, 이는 동적으로 할당된 것이다.
  * 따라서 파일 처리 이후에 파일을 닫아주지 않으면 메모리 누수가 발생한다.

---
## 사용 예제

  ```
  char s[20] = "Hello world!";
  FILE * fp ;
  fp = fopen("temp.txt","w");
  fprintf(fp,"%s",s);
  fclose(fp);
  return 0;
  ```
---
## 파일 입출력
  * 파일 입출력을 이용해 데이터를 파일로부터 가져오거나 데이터를 파일로 내보낼 수 있다.
  * 파일 입출력이 끝난 이후에는 반드시 파일 객체를 메모리에서 할당 해제 해주어야 한다.

  ```
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>

  typedef struct Student{
	   char name[20];
	    int score;
  }Student;

  int main(void){
	   int n, sum = 0;
  	FILE *fp;
  	fp = fopen("input.txt","r");
  	fscanf(fp,"%d",&n);
  	Student *students = (Student*)malloc(sizeof(Student) * n);
  	for (int i = 0 ; i < n ; i++){
  		fscanf(fp,"%s %d",&((students + i) -> name ) , &((students + i) -> score));
  		printf(" name : %s , grade : %d\n", (students+i)->name,(students+i)->score);
  	}
  	for (int i = 0; i < n ; i ++){
  		sum += (students + i) ->score;
  	}
  	free(students);
  	fclose(fp);
  	printf(" average : %.2f\n",(double)sum/n);
  	return 0;
  }
  ```
---
## 전처리기

  * 전치리기 구문은 다른 프로그램 영역과 독립적으로 처리된다.
  * 전처리기 구문은 소스코드 파일 단위로 효력이 존재한다.
---
## 파일 포함 전처리기
  * #include는 전처리기에서 가장 많이 사용되는 문법이다.
  * 특정한 파일을 라이브러리로서 포함시키기 위해 사용된다.
  * #include 구문으로 가져올 수 있는 파일을 제약이 없다.
    - 이와 같이 선언하면 시스템 디렉토리에서 파일을 검색한다.
    - 운영체제마다 시스템 디렉토리가 존재하는 경로가 다를 수 있다.
    - 대표적으로 stdio.h 와 같은 헤더 파일 등이 시스템 디렉토리에 존재한다.
---
## include "파일이름"
  * 이와 같이 선언하면 현재 폴더에서 파일을 먼저 검색한다.
  * 만약 현재 폴더에 파일이 없다면 시스템 디렉토리에서 파일을 검색한다.
  ```
  #include "temp.h"
  ```

    - temp.h 헤더 파일 안에 함수를 선언해두고 다른 프로그램 내에서 사용할 수 있다.(같은 경로내에 있어야 한다.)
    - #include 를 통해 가져오는 파일은 말 그대로 파일의 소스코드를 다 가져오는 것이다.
    - 따라서 의도치 않게 한 번 참조한 헤더 파일을 여러번 참조하지 않도록 유의해야 한다.
---
## 매크로 전처리기
  * 프로그램 내에서 사용되는 상수나 함수를 매크로 형태로 저장하기 위해 사용한다.
  * #define 문법을 사용해 정의할 수 있다.
  ```
  #define PI 3.1415926535
  ```

  * define 문법에는 인자를 포함 할 수 있다.
  ```
  #define POW(x) (x * x)
  ```

  * #define 문법은 소스코드의 양을 획기적으로 줄여준다. (실무 혹은 알고리즘에서 자주 사용됨)
  ```
  #define ll long long
  #define ld long double
  ll a = 987654000; ld b = 100.5054;
  ```
---

## 조건부 컴파일
  * 조건부 컴파일은 컴파일이 이루어지는 영역을 지정하는 기법
  * 일반적으로 디버깅과 소스코드 이식을 목적으로 하여 작성된다.
  * C언어로 시스템 프로그램을 작성할 때에는 운영체제에 따라서 소스코드가 달라질 수 있다.
  * 이 때 운영체제에 따라서 컴파일이 수행되는 소스코드를 다르게 할 수 있다.
  > 동일한 헤더 파일을 여러번 불러 왔을 때 오류가 발생한다.
  > 이때 , 해결을 위해  #ifndef(if not define) ~ #endif 문법을 사용한다.

  ```
  #ifndef _TEMP_H_
  #define _TEMP_H_

  int add(int a, int b){
    return a+b;}
  #endif
  ```
---

## 파일 분할 컴파일
  * 일반적으로 자신이 직접 라이브러리를 만들 때는 C언어 파일과 헤더파일을 모두 작성해야 한다.
  * main.c

  ```
  #include <stdio.h>
  #include "temp.h"

  int main(void){
    printf("%d\n",add(3,5));
    return 0;
  }
  ```

  * temp.h
  ```
  #ifndef _TEMP_H_
  #define _TEMP_H_

  int add(int a, int b);
  #endif

  ```
  * temp.c
  ```
  #include "temp.h"

  int add(int a,int b){
    return a+b;
  }
  ```

---
## 정리
  * 전처리기의 사용은 필수는 아니지만 때에 따라서 소스코드를 획기적으로 줄일 수 있다.
